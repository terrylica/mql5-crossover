---
plan_id: adaptive-cci-normalization
version: 1.1.0
status: phase_1_complete
created: 2025-10-29
last_updated: 2025-10-29

# Objective
objective: |
  Replace fixed CCI thresholds with adaptive percentile-based normalization to achieve
  consistent signal frequency (30% GREEN, 40% YELLOW, 30% RED) across all market regimes.
  Current fixed thresholds produce 99.9% RED, 0.1% GREEN due to miscalibration.

# Service Level Objectives
slos:
  availability:
    target: 100%
    metric: Indicator loads and calculates without errors
    actual: 100%
    status: MET
    measurement: v4.0.0 compiled successfully (10KB .ex5), ready for MT5 attachment

  correctness:
    target: 100%
    metric: |
      Color distribution matches target within ±5%:
      - RED (bottom 30%): 25-35%
      - YELLOW (middle 40%): 35-45%
      - GREEN (top 30%): 25-35%
    actual: 0%
    status: NOT_MET
    measurement: Current: 99.9% RED, 0.1% YELLOW, 0.1% GREEN

  observability:
    target: 100%
    metric: Percentile rank scores exported to CSV for validation
    actual: 0%
    status: NOT_MET
    measurement: Not yet implemented

  maintainability:
    target: 100%
    metric: |
      Implementation uses native MQL5 (no external dependencies)
      Code follows indicator patterns from ~/.claude/skills/mql5/indicator-patterns/SKILL.md
    actual: 100%
    status: MET
    measurement: Research validated native MQL5 implementation is viable

# Architecture
approach: |
  Single-window percentile rank normalization (Phase 1):
  - Maintain rolling window of 120 raw CCI values
  - Calculate percentile rank: count(CCI < current) / window_size
  - Map percentile rank to colors: <0.3=RED, 0.3-0.7=YELLOW, >0.7=GREEN
  - Native MQL5 implementation (~20 lines, ~0.001ms per calculation)

# Research Findings
research:
  dataset: 200,843 bars EURUSD M12 (2025-09-01 to 2025-10-29)
  location: experiments/adaptive-cci-normalization-research/

  raw_cci_distribution:
    mean: 2.47
    stdev: 114.05
    range: [-664.14, 602.29]
    iqr: 170.39
    coverage_fixed_bounds: 59.2%  # [-100, +100] captures only 59.2%
    coverage_target: 75.0%  # Should capture 75%

  current_bottleneck:
    component: V (dispersion 1-stdev/50)
    frequency: 96.3% of bars
    reason: |
      Fixed C1=50 threshold vs actual stdev mean=92.5
      V component clamps to zero in 96% of bars
      Multiplicative formula amplifies zero components

  adversarial_validation:
    tests_run: 6
    tests_passed: 5
    tests_failed: 1
    confidence: 95%

    test_1_regime_change:
      result: PASS
      adaptation_lag: 0 bars (instant)

    test_2_outlier_robustness:
      result: PASS
      max_contamination: 20%

    test_3_market_types:
      result: PASS
      trending_distribution: [29.5%, 37.3%, 33.2%]  # RED, YELLOW, GREEN
      ranging_distribution: [29.8%, 39.7%, 30.6%]
      target_distribution: [30%, 40%, 30%]

    test_4_window_sizes:
      result: PASS
      optimal_window: 120 bars
      stable_minimum: 60 bars

    test_5_skewness:
      result: PASS
      max_skew_tested: 0.477
      distribution_free: true

    test_6_multi_scale:
      result: UNEXPECTED
      finding: Single-window outperforms multi-scale ensemble
      single_std: 0.253
      multi_std: 0.265 (5% higher volatility)
      recommendation: Use single-window (120 bars)

  python_modules_benchmarked:
    numba_jit:
      time_per_10k: 0.000s
      speedup: 100x vs NumPy
      complexity: Medium

    bottleneck:
      time_per_10k: 0.001s
      speedup: 10x vs NumPy
      complexity: Low
      recommended_for: Python prototyping

    numpy:
      time_per_10k: 0.017s
      speedup: 1x baseline
      complexity: Low

    pandas:
      time_per_10k: 0.277s
      speedup: 0.1x (10x slower)
      complexity: Lowest

  mql5_python_integration:
    verdict: NOT_RECOMMENDED
    reason: 1000-10,000x performance penalty

    native_mql5:
      latency: 0.001ms
      complexity: 20 lines of code
      deployment: Single .ex5 file
      production_viable: true

    dll_python_c_api:
      latency: 1-5ms
      penalty: 1000x slower
      complexity: 200+ lines
      deployment: .ex5 + .dll + Python runtime
      production_viable: false

    named_pipes_ipc:
      latency: 10-50ms
      penalty: 10000x slower
      production_viable: false

    file_based:
      latency: 100-500ms
      penalty: 100000x slower
      production_viable: false

# Components
components:
  - name: research_artifacts
    location: experiments/adaptive-cci-normalization-research/
    files:
      - COMPREHENSIVE_RESEARCH_REPORT.md (25KB, complete findings)
      - README.md (7.6KB, quick start)
      - adversarial_percentile_tests.py (18KB, 6 empirical tests)
      - python_statistical_modules_research.py (13KB, benchmarks)
      - mql5_python_integration_research.md (15KB, integration analysis)
    status: COMPLETE

  - name: adaptive_indicator_implementation
    location: Program Files/MetaTrader 5/MQL5/Indicators/Custom/Development/CCINeutrality/
    files:
      - CCI_Neutrality_Adaptive.mq5 (v4.0.0 source, 230 lines)
      - CCI_Neutrality_Adaptive.ex5 (v4.0.0 compiled, 10KB)
    status: COMPLETE

  - name: validation_tools
    location: users/crossover/
    files:
      - validate_adaptive_normalization.py (compare MQL5 vs Python reference)
    status: PENDING

# Implementation Plan
phases:
  - phase: 1
    name: Single-Window Percentile Rank
    status: COMPLETE
    complexity: Low
    time_estimate: 2 hours
    actual_time: 30 minutes
    expected_improvement: 300x more GREEN bars (0.1% → 30%)

    tasks:
      - Add input parameter: InpAdaptiveWindow (default 120) - COMPLETE
      - Maintain rolling window: double cci_window[120] - COMPLETE
      - Implement PercentileRank() function (10 lines) - COMPLETE
      - Replace color assignment logic (5 lines) - COMPLETE
      - Test on EURUSD M12 chart - PENDING (Phase 2)
      - Export scores to CSV - PENDING (Phase 2)
      - Validate color distribution (30-40-30 target ±5%) - PENDING (Phase 2)

    dependencies:
      - CCI_Neutrality_ScoreOnly_ColorHist.mq5 (current version) - COMPLETE

    x-implementation-findings:
      implementation_simplicity: |
        Actual implementation was simpler than estimated. Removed all multiplicative
        scoring complexity (p, c, v, q components) and replaced with single percentile rank.
        Total code: 230 lines (vs 318 lines original), ~28% reduction.

      algorithm_efficiency: |
        Percentile rank calculation is O(n) where n=window_size (120).
        Simple loop counting values below current (no sorting needed).
        Estimated ~0.001ms per calculation matches research predictions.

      code_changes_summary: |
        - Removed 7 input parameters (InpMinStreak, InpMinInChannel, InpMaxMean, InpMaxStdev, InpMinScore, InpC0, InpC1, InpC2, InpLowThreshold, InpHighThreshold)
        - Added 1 input parameter (InpAdaptiveWindow=120)
        - Removed rolling sum state variables (sum_b, sum_cci, sum_cci2, sum_excess)
        - Added PercentileRank() function (10 lines)
        - Simplified OnCalculate loop (removed 100+ lines of rolling sum logic)
        - Changed indicator scale from 0.0-0.1 to 0.0-1.0 (percentile rank range)

      compilation_success: |
        Compiled successfully using CrossOver CLI compilation method (~1s)
        Output: CCI_Neutrality_Adaptive.ex5 (10KB)
        No compilation errors or warnings

      next_phase_readiness: |
        Ready for Phase 2 validation. Indicator can be attached to MT5 chart immediately.
        No blockers identified.

    code_snippet: |
      double PercentileRank(double value, double &window[], int size) {
          int count_below = 0;
          for(int i = 0; i < size; i++) {
              if(window[i] < value) count_below++;
          }
          return (double)count_below / size;
      }

      // In OnCalculate:
      static double cci_window[];
      ArrayResize(cci_window, InpAdaptiveWindow);

      // Update window (rolling)
      cci_window[i % InpAdaptiveWindow] = current_cci;

      // Calculate score
      double score = PercentileRank(current_cci, cci_window, InpAdaptiveWindow);

      // Color mapping
      if(score > 0.7)      BufColor[i] = 2;  // GREEN
      else if(score > 0.3) BufColor[i] = 1;  // YELLOW
      else                 BufColor[i] = 0;  // RED

  - phase: 2
    name: Validation and Tuning
    status: PENDING
    complexity: Low
    time_estimate: 1 hour

    tasks:
      - Export 5000 bars with adaptive scores
      - Run Python validation (correlation check)
      - Verify color distribution matches 30-40-30 target
      - Test on multiple symbols (GBPUSD, USDJPY, XAUUSD)
      - Test on multiple timeframes (M5, M15, H1, H4)
      - Document findings in plan

    acceptance_criteria:
      - Color distribution within ±5% of target
      - Works across all major symbols
      - Works across all timeframes
      - MQL5 vs Python correlation > 0.999

  - phase: 3
    name: Production Deployment
    status: PENDING
    complexity: Low
    time_estimate: 30 minutes

    tasks:
      - Update version to v4.0.0
      - Clean up debug code
      - Update documentation
      - Merge to main branch

    dependencies:
      - Phase 2 validation complete
      - All SLOs met

# Rejected Alternatives
rejected:
  - approach: Multi-scale ensemble (30, 120, 500 bar windows)
    reason: |
      Adversarial Test 6 showed single-window (120 bars) outperforms multi-scale.
      Multi-scale has 5% higher volatility (std 0.265 vs 0.253).
      Added complexity with no benefit.

  - approach: Python integration via DLL
    reason: |
      1000x performance penalty (0.001ms → 1-5ms per calculation)
      Deployment complexity (.ex5 + .dll + Python runtime)
      Percentile rank algorithm is simple enough for native MQL5

  - approach: Fixed threshold relaxation (C0=104, C1=124)
    reason: |
      Only 10x improvement (0.1% → 1% GREEN bars)
      Still regime-dependent (fails in extreme volatility)
      Adaptive approach is superior (300x improvement, regime-independent)

  - approach: Weighted additive formula
    reason: |
      Changes neutrality definition (compensatory vs multiplicative)
      Root cause is threshold miscalibration, not formula choice
      Adaptive normalization solves threshold issue directly

# Current Status
progress:
  completed:
    - Empirical distribution analysis (200k bars)
    - Adversarial testing (6 tests, 95% confidence)
    - Python module benchmarking (4 methods)
    - MQL5-Python integration analysis
    - Comprehensive research report (25KB)
    - Phase 1 implementation (v4.0.0, 230 lines MQL5, 10KB .ex5)

  blocked: []

  pending:
    - Phase 2 validation
    - Phase 3 deployment

# Next Steps (Prioritized)
next_steps:
  - priority: 1
    action: Implement Phase 1 (Single-Window Percentile Rank)
    rationale: |
      Research validates this approach (95% confidence from 6 adversarial tests).
      Expected 300x improvement in signal frequency.
      Simple implementation (~20 lines of MQL5 code).
    command: |
      # Edit CCI_Neutrality_ScoreOnly_ColorHist.mq5
      # Add PercentileRank() function
      # Replace color assignment logic
      # Compile and test
    time_estimate: 2 hours

  - priority: 2
    action: Validate color distribution on EURUSD M12
    rationale: |
      Verify implementation matches research predictions.
      Target: 30% RED, 40% YELLOW, 30% GREEN (±5%).
    command: |
      # Attach indicator to EURUSD M12 chart
      # Export 5000 bars to CSV
      # Run: uv run validate_adaptive_normalization.py
    time_estimate: 30 minutes
    dependencies:
      - Phase 1 complete

  - priority: 3
    action: Test on multiple symbols and timeframes
    rationale: |
      Ensure adaptive approach works universally.
      Test robustness across different market conditions.
    symbols: [EURUSD, GBPUSD, USDJPY, XAUUSD]
    timeframes: [M5, M15, H1, H4]
    time_estimate: 1 hour
    dependencies:
      - Phase 1 complete
      - EURUSD M12 validation passed

  - priority: 4
    action: Deploy to production (v4.0.0)
    rationale: |
      All SLOs met, ready for production use.
    command: |
      git add .
      git commit -m "feat: Implement adaptive percentile rank normalization v4.0.0"
      git push origin feature/adaptive-normalization
    time_estimate: 30 minutes
    dependencies:
      - All validations passed
      - All SLOs met

# References
documentation:
  research:
    - experiments/adaptive-cci-normalization-research/COMPREHENSIVE_RESEARCH_REPORT.md
    - experiments/adaptive-cci-normalization-research/README.md
    - users/crossover/ADAPTIVE_NORMALIZATION_SPEC.md

  data:
    - Program Files/MetaTrader 5/MQL5/Files/cci_debug_EURUSD_PERIOD_M12_2025.10.29.csv (200k bars)
    - users/crossover/analyze_cci_distribution.py (distribution analysis script)

  related_plans:
    - docs/plans/cci-neutrality-indicator.yaml (base indicator v1.3.2)

# Changelog
changes:
  - version: 1.1.0
    date: 2025-10-29
    description: Phase 1 implementation complete (Single-Window Percentile Rank)
    changes:
      - Implemented v4.0.0 CCI_Neutrality_Adaptive.mq5 (230 lines)
      - Added PercentileRank() function (10 lines, O(n) complexity)
      - Removed 7 input parameters (fixed thresholds), added 1 (InpAdaptiveWindow=120)
      - Removed 100+ lines of multiplicative scoring logic
      - Simplified OnCalculate loop (no rolling sums needed)
      - Changed indicator scale from 0.0-0.1 to 0.0-1.0 (percentile rank range)
      - Compiled successfully using CrossOver CLI (~1s compile time)
      - Output: CCI_Neutrality_Adaptive.ex5 (10KB)
      - Code reduction: 318 lines → 230 lines (~28% simpler)
    slos:
      availability: 100% (indicator compiled and ready for attachment)
      correctness: 0% (pending Phase 2 validation)
      observability: 0% (pending Phase 2 CSV export)
      maintainability: 100% (native MQL5, no dependencies)

  - version: 1.0.0
    date: 2025-10-29
    description: Initial plan creation after research phase completion
    changes:
      - Analyzed 200,843 bars of EURUSD M12 data
      - Identified root cause (V component bottleneck in 96.3% of bars)
      - Fixed thresholds (C0=50, C1=50) vs actual distribution (mean |mean|=53, mean stdev=92.5)
      - Raw CCI [-100, +100] captures only 59.2% (should be 75%)
      - Researched adaptive percentile rank approach
      - Validated via 6 adversarial tests (95% confidence)
      - Benchmarked Python statistical modules (Numba, Bottleneck, NumPy, Pandas)
      - Evaluated MQL5-Python integration (rejected due to 1000x penalty)
      - Rejected multi-scale ensemble (single-window outperforms)
      - Recommended Phase 1 implementation (single-window, 120 bars)
    slos:
      availability: 0% (not implemented)
      correctness: 0% (not implemented)
      observability: 0% (not implemented)
      maintainability: 100% (native MQL5 validated)
